{"componentChunkName":"component---src-pages-blog-template-js","path":"/content/posts/autoencoders/2016-07-18-AutoEncoders/","result":{"pageContext":{"html":"<p>Quite in line with the last blog posts about <a href=\"https://jotterbach.github.io/2016/03/24/Principal_Component_Analysis/\">Principal Component Analysis (PCA)</a> and <a href=\"https://jotterbach.github.io/2016/05/23/TSNE/\">t-distributed Stochastic Neighbor Embedding (t-SNE)</a> I want to discuss another dimensionality reduction technique that originated in the Neural Network (NN) community, known as <a href=\"https://?\">Autoencoders</a>.</p>\n<p>The idea behind an autoencoder is conceputally quite simple and results in very powerful outcomes if applied correctly. Unfortunately, however, it suffers from the typical problem of NNs in that the outcomes are not readily interpretable<sup id=\"fnref-fn-images\"><a href=\"#fn-fn-images\" class=\"footnote-ref\">fn-images</a></sup> and somewhat harder to train. But before we jump into the autoencoder let's do some preparatory work for motivation and understanding. The <a href=\"https://github.com/jotterbach/dstk\">code</a> and and a <a href=\"https://github.com/jotterbach/Data-Exploration-and-Numerical-Experimentation/blob/master/Numerical-Experimentation/AutoEncoder_for_AdsDataset.ipynb\">notebook</a> are available on my personal github.</p>\n<h2>Lossy compression</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 340px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/099b91457d41f595b0d8f8dd3d59bf04/9f933/simple_noisy_model.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.54054054054055%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAACmklEQVR42o1T204TURSdAor6oPHFpH/AswoJCYlN5IHEz5DoEw/8AH0RfkLjJRoTo9EEBBoRiWg1NRIUkBZ6G3qZTs9cOzOll7ks9ykFGhMTTrKy9j5n9jr7ckYQumt5+XPYNBv3GLMmNc05I6xJmRmTFHPXtNr3mYOwAKCPCxYK0nAQAI7jBYeHAf6Luo8650YAy2mjkJNQqmh+w2oBths5EUylssO1WhOKYrUJnqraHucTqLRHXFUdTxErnirpnkFs/sl4+flYO/nyNdILKxFhampqkAvu7OyN2HYb1aoZkABUxSZYdEENVBIx+XodekmBnsqjelCFmNhE+s08UosrvpLMIZPYuC2Mj49f4YKZzMEN23F5sK8wClZtKFxIdaDVWtAPZLC8BDH2CekvP7D3bhHF1XVUtlLQylQyXWQk8xFhdHT0GukNiGV23TYaR4KUjVFkMNIFsKKCwvsPyD9+jv1HzyB+/g55PQHjdxLmbhZqWUNVq/sWxSrpYkQYG7tzlQRDvId1ykiTzYBliiglfiE9H0P64VPkllYhiRXoJGBkS5S9A6VqQuEJUCWM1XzLdrkfESYmJi7zkre2kje1zV3sv3jlc6Hs0kfIG9vQt/ehU8Z6WYVCQ2NanQ+u0wreZ27zqmzL5X3uTDnEBWNvYyPZtTjkta9t7dtP16jorsJqHqs1XcrAVVTbpSHxPVfhfASvyy16w1z41uk7XIiNoOmi5SNoeQGabaDVOhuaTfikA9dF5PhHEZ5Eo0NSKjcnM2uGyeaMmJPmcgTGfUKhUH0gipXZY5/boih3zmX6XpK02Xg8PnQiGA6HLxH1C6drgHC+x+f24D/n53r8UFfjdFHW/T3o66JjR6PRC9PT0xd793rsY4T+Ar1V+p7nEnEtAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Linear model wtih noise\"\n        title=\"\"\n        src=\"/static/099b91457d41f595b0d8f8dd3d59bf04/9f933/simple_noisy_model.png\"\n        srcset=\"/static/099b91457d41f595b0d8f8dd3d59bf04/12f09/simple_noisy_model.png 148w,\n/static/099b91457d41f595b0d8f8dd3d59bf04/e4a3f/simple_noisy_model.png 295w,\n/static/099b91457d41f595b0d8f8dd3d59bf04/9f933/simple_noisy_model.png 340w\"\n        sizes=\"(max-width: 340px) 100vw, 340px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\nTo illustrate the idea let's look at a simple model where we have two dimension that follow the relationship</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>y</mi><mo>∼</mo><mi>α</mi><mo>+</mo><mi>β</mi><mi>x</mi><mo>+</mo><mi>ϵ</mi></mrow><annotation encoding=\"application/x-tex\">y \\sim \\alpha + \\beta x + \\epsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ϵ</span></span></span></span></span></div>\n<p>with a noise term <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϵ</mi><mo>∼</mo><mi mathvariant=\"script\">N</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>0.1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\epsilon \\sim \\mathcal{N}(0, 0.1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ϵ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.14736em;\">N</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">0.1</span><span class=\"mclose\">)</span></span></span></span></span>, a bias <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span> and a slope <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span> as show in the figure to the left. To truthfully represent the full data we would have to store <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">2N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span> floats as we have two dimensions and <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span> data points. However, it is quite obvious that we would also store a lot of the noise that is actually not important for the model. If we can afford to \"loose\" some information it would be possible to store the data with just <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">N+2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span></span> floats -- <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span> values for <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span>, the bias <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span> and the slope <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>. For large <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span> we would get a compression of a factor <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span></span> by reducing the noise. As a side benefit, we made the considerably simplified the data, as we reduced the number of dimensions from two to one! This is the general idea for lossy compression algorithms<sup id=\"fnref-fn-jpeg\"><a href=\"#fn-fn-jpeg\" class=\"footnote-ref\">fn-jpeg</a></sup> to reduce the data by removing \"noise\".  The idea of removing noise to reduce data is directly generalizable to higher dimensions, though technically significantly more challenging.</p>\n<h2>Non-linear Representations in Neural Networks</h2>\n<p>The second ingredient we need before diving into the Denoising Autoencoder (DAE) is to understand what simple NNs learn to separate features that are not linearly separable. I will steal this beautiful example from <a href=\"https://colah.github.io/posts/2015-01-Visualizing-Representations/\">Chris Olah's blog</a> which is defintely worth reading as well.\nLet's have a look at the blue and red curves in the original image below\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.810810810810814%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAv0lEQVR42pWR2wqCQBCGe/8niG57gyASi4oIvcgCo8NWVGogCCaKp13dQ1Ob2E1G38Ww7Mz3z8K2xAuMcZ4mOM+iKArDMAgC3/fvFfIsKwzAsLRalFLzZGub/WS5NtEZQjAmZVnSL0CrlguCu9NVRz+050gxdkJwLprgnNcyJmQ7nCHVQAPtqBvNJsAY+5CLwlLGSX8U9lRbW7C/ZHhGHMfW5XpznCzLf7kiTRPP8yDiKb+vwKvymoG/cF1XrnkAhAeSU4y9rkYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Logit on linearly inseparable classes\"\n        title=\"\"\n        src=\"/static/e81b97abca45503bb92359bca506ff3b/fcda8/netvis-simple-NoHid.png\"\n        srcset=\"/static/e81b97abca45503bb92359bca506ff3b/12f09/netvis-simple-NoHid.png 148w,\n/static/e81b97abca45503bb92359bca506ff3b/e4a3f/netvis-simple-NoHid.png 295w,\n/static/e81b97abca45503bb92359bca506ff3b/fcda8/netvis-simple-NoHid.png 590w,\n/static/e81b97abca45503bb92359bca506ff3b/9f82e/netvis-simple-NoHid.png 820w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\nA neural network without any hidden layers and a sigmoid activation function is a fancy way of writting a <a href=\"https://?\">Logistic Regression</a> which is a linear model. The trained models learns that the best possible way to split the two curves by classifying samples within the blue and red shaded regions. However, in the center we have misclassification of blue points, whereas on the edges we misclassify red points. The linear decision boundary minimizes the misclassification rate as any other linear separator would do a worse job.</p>\n<p>The introduction of a hidden layer changes the game dramatically!\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1b831b86fc68f81485ec7cc4e0165e3a/d4c13/netvis-simple-2S.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.486486486486484%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAABEUlEQVR42l2Q3U6DQBSE+/4voE/gpWkvsCS2NSCWIgZpQ1KlKjX8LhRKSYSFXRZPISI6F5vN7HxnNmfUtMK4CH3PdWxrv7dt27Isz3GiwDtlpzTL4oGSJCnLsqNGlNLV9kPcbPlHXTFMXBRfeQ6nom/G0rMqP3nmrqK0bsUYI4QM4BJP5uqFbF7evzwoa7DY2WdX4poTjWQy+7wVSlY3P4IRvzDc3OlCm2sGL/vSqm5p4LXZsuAEciMg3cCU9DD8dACT6pW/Q+Ope829LdW2lQG8WwiBpBzfrTAM+/T/5m4YQugQx/DQh0hd+4fIRaiqqmYgWGEQBF1y1Fl5nhcYD0NQf0ziKAxhQ3/gNIUmjM/l38C0h2DmOrkbAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"NN on linearly inseparable classes\"\n        title=\"\"\n        src=\"/static/1b831b86fc68f81485ec7cc4e0165e3a/fcda8/netvis-simple-2S.png\"\n        srcset=\"/static/1b831b86fc68f81485ec7cc4e0165e3a/12f09/netvis-simple-2S.png 148w,\n/static/1b831b86fc68f81485ec7cc4e0165e3a/e4a3f/netvis-simple-2S.png 295w,\n/static/1b831b86fc68f81485ec7cc4e0165e3a/fcda8/netvis-simple-2S.png 590w,\n/static/1b831b86fc68f81485ec7cc4e0165e3a/d4c13/netvis-simple-2S.png 825w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\nThe NN learns a non-linear transformation, that makes the two classes <em>linearly separable in the hidden layer</em> and hence forms a non-linear decision boundary in the original input space. To visualize this we can look at the distorsions of the underlying grid, when going from the input to the hidden layer. As a result the NN is able to perfectly speparate those classes<sup id=\"fnref-fn-overfitting\"><a href=\"#fn-fn-overfitting\" class=\"footnote-ref\">fn-overfitting</a></sup>!</p>\n<h2>The Denoising Autoencoder</h2>\n<p>Now we can tackle the DAE: We combine the concepts of lossy compression and non-linear representation. The idea is to learn a non-linear representation of the data that minimizes noise while maximizing the ability to truthfully restore the data from the compressed format. The network structure is quite simple and consist of two major components, the encoder and the decoder network.</p>\n<p><strong>Encoder:</strong> Here, we start with <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span> input nodes, corresponding to the dimensionality of the input data and reduce this to <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span> nodes corresponding to the desired dimensionality size of the compressed data, i.e. we learn a function</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>e</mi><mo>:</mo><msup><mi mathvariant=\"double-struck\">R</mi><mi>m</mi></msup><mo>↦</mo><msup><mi mathvariant=\"double-struck\">R</mi><mi>k</mi></msup><mo separator=\"true\">,</mo><mi>x</mi><mo>→</mo><mi>z</mi><mo>=</mo><mi>σ</mi><mo stretchy=\"false\">(</mo><mi>e</mi><mo>⋅</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">e: \\mathbb{R}^m \\mapsto \\mathbb{R}^k, x \\rightarrow z = \\sigma(e\\cdot x).</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7254em;vertical-align:-0.011em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0935em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">.</span></span></span></span></span></div>\n<p>where <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span></span> is the activation function and <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">e</span></span></span></span></span> is a <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">k\\times m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span> matrix of weights. Even though this looks like a simple matrix multiplication, this need not be the case as we can string several hidden layers together to for the transformation <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">e</span></span></span></span></span>, thus making the represeantaion more non-linear.</p>\n<p><strong>Decoder:</strong> there are two generally used decoder types - the tied and untied decoder. In case of a tied decoder, we use the inverse transformation <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>e</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">e^{-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span></span>, which for a single layer is just the matrix transpose. This results in a stiffer system, but has the advantage of a having to learn fewer parameters and is hence less prone to overfitting. The untied decoder learns a complete separate representation:</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>d</mi><mo>:</mo><msup><mi mathvariant=\"double-struck\">R</mi><mi>k</mi></msup><mo>↦</mo><msup><mi mathvariant=\"double-struck\">R</mi><mi>m</mi></msup><mo separator=\"true\">,</mo><mi>z</mi><mo>→</mo><mi>σ</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mo>⋅</mo><mi>z</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">d: \\mathbb{R}^k\\mapsto \\mathbb{R}^m, z \\rightarrow \\sigma(d\\cdot z).</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9101em;vertical-align:-0.011em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9088em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span><span class=\"mord\">.</span></span></span></span></span></div>\n<p>to efficiently map the compressed data to the originial input space. Here <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span></span> is a <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">k\\times m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span> matrix. This type needs much more training data as the complete network has typically twice as many parameters as the tied autoencoder network.</p>\n<p><strong>Learning objective:</strong> The reason why this system is called <em>autoencoder</em> is the objective funtion the system wants to minimize:</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>L</mi><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><mo stretchy=\"false\">(</mo><mi>x</mi><mo>−</mo><mi>σ</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mo>⋅</mo><mi>σ</mi><mo stretchy=\"false\">(</mo><mi>e</mi><mo>⋅</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">L = \\sum_i (x-\\sigma(d\\cdot \\sigma(e\\cdot x)))^2.</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.3277em;vertical-align:-1.2777em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.05em;\"><span style=\"top:-1.8723em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span><span style=\"top:-3.05em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.2777em;\"><span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1141em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mord\">.</span></span></span></span></span></div>\n<p>It tries to optimize the decoded representation of the data with respect to itself. It should be pointed out that the loss function doesn't need to be a squared error loss, but can be chosen appropriately for the input data, e.g. log-loss for binary input data. Note that depending on the activation function the input data needs to be scaled. E.g. the sigmoid clamps the output to the interval <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[-1, 1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></span> and hence the data has to be scaled to fit within this range for the autoencoder to work correctly.</p>\n<h2>What is this good for?</h2>\n<p>The first thing to note is that it an unsupervised technique, meaning it doesn't need labelled data. This in turn means that it can be used for clustering or as a feature preprocessor by learning new representations. Learning an encoder lets us reduce the dimensionality of the data while preserving a lot of information by learning important, potentially nonlinear, features. The dimensionality-reduced data can then be fed into a unsupervised / semi-supervised clustering algorithm that can now perform its magic without suffering from the <a href=\"https://jotterbach.github.io/2016/05/23/TSNE/\">Curse of Dimensionality</a>. In some cases further clustering might not even be necessary as the non-linear features already learn such structures in the compressed data.</p>\n<p>A second use case is the pretraining of a Deep Neural Network (similar to a Deep Belief Network). In this case the autoencoder learns a good weight initialization that can then be used to further train the network using supervised techniques</p>\n<p>###Example\nTo demonstrate the workings of the autoencoder, I want to create a two-dimensional visualization of the <a href=\"https://archive.ics.uci.edu/ml/datasets/Internet+Advertisements\">Internet Advertisment dataset</a>. The data contains 1560 features and only 3300 records. Hence we easily run into the curse of dimensionality as the density in the high-dimensional space is quite small. <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 531px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 69.5945945945946%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAAC20lEQVR42o2RTUwTURDHN0Fjot64qCdDPHshpsRgvJiAJp4QEy8eiRfOykHjwRjPGmO8oEEP2Foq6kVEJBoRGgK0prTQQrftdr+/urv9YD/eOG8LCGqML5nMvHnzfvnPDDM0NHSQYZjjm/nSVU2r3VUU56aqWiN7TdetkWpVHZEkM4x38oKgh6brzi1ZNu+YZrOLAYAOBDILaTFmNfEWgOe6BDwPds33ARxnC1otP7zTd5prNNzQMBfgT+r7mWg0BB75lsxNJH8IoGtOU5Ytb68piu1VKoonCEYYS1It9KgaTaPxlmG0QJKcvl2F+Q0uvphRgONNWgAIwgIr9PSOQEBgGCMw9AhE02hNYNseBfYzg4ODRymwyonxTMGA1bzsmUYdJLkN2wFynPoXoAY8/xuwt7e3i7bMstwbVW9BMl31VNUGUawBL5igYazi5zIqxKUAfVOUWugpDJeCdytwHA80DYE9PT2nqMJSSYw1GgGksoKXTHNQquiwnOFDcJkzYH6ZBUk0oT2OtkIK5Hl9v8JIJHKSKiwUypM06dQa3kKKg1cfsrCUESBfVCGVE+HtTBYVG6iiDfylUNuvcHh4+BBVWCwKMQqkW6Vtxqdz8CS2DN9XKvBpvggv362EM5SV9jhkuT3XP2a4veXDhUIlQZPYiosFpGbWyecFltwfnSc3HkyT249niaqYxNAdYmg2wcURgdcIbpqgQt+23X1AhmWrcdv2Q4WyYoVbRmg4qy+LZRhNLEE6K0BmXaZzhtWCDBtFCedq0MUFjbrfbnkHuLlZjVsWVWi5CPFpG4JoEho7VtOXRZ2wZTVI5yTv62KJvP64Rp5NpvzVNSFgK7pfFeuwWTb7mO3TGY2+7+Y47ayq1iPj44mBubmlC64L3VNTs5eev4heKfPmmXR6/fxELHatocvnUMiZsbHxgYdPYxejM6Xue48SfZcHrp9m/uMcQDuBdmzbd/6jtuMnVaVR642Z4fIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Training loss for Autoencoder\"\n        title=\"\"\n        src=\"/static/a18f70647508c9135cf8eed33e2b8230/d4713/traing_loss_ads.png\"\n        srcset=\"/static/a18f70647508c9135cf8eed33e2b8230/12f09/traing_loss_ads.png 148w,\n/static/a18f70647508c9135cf8eed33e2b8230/e4a3f/traing_loss_ads.png 295w,\n/static/a18f70647508c9135cf8eed33e2b8230/d4713/traing_loss_ads.png 531w\"\n        sizes=\"(max-width: 531px) 100vw, 531px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>{: .text.img-right width=\"60%\"} Using a deep autoencoder to reduce the dimensionality to two dimensions we can get an intuition about how the data is distributed and what kind of features can be learned. For the plots, I implemented my own Autoencoder using <a href=\"https://www.tensorflow.org/\">TensorFlow</a><sup id=\"fnref-fn-jmetzen\"><a href=\"#fn-fn-jmetzen\" class=\"footnote-ref\">fn-JMetzen</a></sup>. The code can be found in the <a href=\"https://github.com/jotterbach/dstk\">DataScience ToolKit</a> package on my github repository. The figure showing the training losses displays the typical learing curve of a Neural Network in that it has plateaus followed by steep rapid descends in loss. The black dashed lines indicate the epochs where the learning rate was adjusted.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 523px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7610c474bb45d522806fabb43f7b24cb/3e286/first_layer_output.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.27027027027026%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAACwklEQVR42p2SbUhTYRTH7ygIM79ksZgmBEH0zT61ClJzhqyBRZiUlL1Lg0DS7EPSqEDJqBD6lPSimSKW2QhD+iBFWWTOZosY+DJouu3ebXf33r3k7nZO59lMUGYfOvDnPPe55/nf3zn34TiO0+j1+jyeF+v8fvm2IEjNfr/U8h+6FQqFtnIsLBbLWlUFO1LE45hUVcR/KZFATCbTa6oHJoDUs4H5aYqKivJ5XhoXxRgKgjzP87LKROslmSkQCKtTM7w67nCrQVrzghynfSYQBKU0RVhfX59NhhOyHEfKSXqJTGS0JPt8EoblKDqcHnzUP4aKFGV7wBQIRNDrVdKE5eXljHBCUeJ0WEoyAyaa6WJmhmIwjESHTwZs+Oz1NzKMMABgCgYjVEeGWq02mxHSQftKhH/pJDGC9p9zWHPtFXaQqUyE3uWEBQXaLQaDQbcSITMLBhT2oVSL70en8ZTFmjJUqH3fckKK1WazeV2mGaYpFZxyCTg7J2JUiaVaPd70Erus45kJWRiNxk0+X+j7ckImNrfhz1M4OSOgGovji7c/8HBDH/2Ur+mfkoEwdQ/JiGY4zwwTrIjJ4w1BWIrCiM0FHo8IbncA7nV+AP3Jx3D57hD4BZno5CTriq4TEYbShiaTaQMjZC0TFREqVKxANPwbbI5f0P58FO93f8K61kE8e8MKe053QMOdIZphDEJiBIgM/Kzl2VBZyrCtbXCN3x+xK4rK5pbweiX85Q7Cuy/TcP6mFYvPdUJJbRcaLjyFg5d6oczcjZWNffBxzIUjYy5wOL2gUHeLMywsLNw4MPDmgMsllPb29R8dsTkNbQ/6K3ZVXa/cWdNevPdI0wnjxa6SfdWth3Yfa6nYX9tetqPialX1lZ5i05nmqoc9w6ZJ54yxsbFxO7cQmgVlCk3++qw8nS4nd3Nulm5bLpfDrRyr/gAT2jKLIuzFlAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Output values of first layer\"\n        title=\"\"\n        src=\"/static/7610c474bb45d522806fabb43f7b24cb/3e286/first_layer_output.png\"\n        srcset=\"/static/7610c474bb45d522806fabb43f7b24cb/12f09/first_layer_output.png 148w,\n/static/7610c474bb45d522806fabb43f7b24cb/e4a3f/first_layer_output.png 295w,\n/static/7610c474bb45d522806fabb43f7b24cb/3e286/first_layer_output.png 523w\"\n        sizes=\"(max-width: 523px) 100vw, 523px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>To ensure that the autoencoder is not saturated, i.e. that the hidden layers by default output <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span> or <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span></span> we look a the mean value of the outputs of the first layer (and strictly speaking we should also look at the other layers).</p>\n<p>To see what feature distribution the network learned, we can look at a scatter plot of the encoded representation. Note that the AE distributed the features nicely across the range <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>×</mo><mo stretchy=\"false\">[</mo><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[-1, 1] \\times [-1,1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></span> making maximum use of the available space; another indication that the individual layers are not saturated.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/55a4d12aafa4699538801d1a8bf6a038/29492/encoded_representation.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.94594594594594%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAADe0lEQVR42n1TW2gcVRieBiyIeCGgvgm+lBAheciT4EPqgxdE9EF8V/DBLIhvIhSDVrRBKVULvdgqLTYrJtkNNGnIatJtNJt0k3Qv2W2y3exmL7OzmTlz3ZnZzc5Mzuc5tbV9EH/4+G/nfPznP/8vCP/Io6Iov6dprVOKYn3NMKbr1hjXHKr6QD8MnWG37o6JkvFVdbdxWtOsFwUAhzhj1zuIMBsHBzTwfaDb5TYQBAD3uc31fd9jeZ/FlEobKnG8DvM7rhe6V6BwWJG1CDGB2Vhrf1d0fbft+DtF06/VHZ+Qln87b/qybPmSZPkKsf09SfflStNvyYpfze+05e06TDf48N8KtbYXURJbWLicCeYvZbGyKGJyUsWtpRpMzcB8zERyzUJ5x4DltFGI53Dtyh2kbu4hObHuGbkG9E4QEoaGhp7kPVRMZ1rNVrFX2A0WRq8g+s0S5OQGpFvbqJQNENnAzhaBbHRRTIuYO/Yb/pipIx5rgBDL48+XZTMkDAwMPM8rtGw7kk7a7EI7WEnquPD5Oki5hnJjH5m8BbGqQdksYG1mE6WSiXQ4jp9fOobExUVUai0v95eOTsB62N/f/xzje0wx7GmtrGI7cScorZexMCNCtjwsn4lh7bsIiNHBnmxjKSZifl7FzXQHE88MI/7uRyD78II2WKV2SOjr6zvCCHuI5kxZuo+187Fg/OMork1UIEsaCskK8vMpkAZBkxFeOrGBkyM3MBsu49yRDzD92SQKM8tes+rBdt2QMDg4+BSvsCmq02wiUEuXgrMnK/j2eBU/vXICq2NhJKI55LM6wsfjyC3eRv5GAY21HL5/60cs/pJBY6vi1f/cgQ2EhNHR0R7eQ2J2p5xSHcUt4l/+1aLjn8zS2U/DNH4xQa+ez9DwD5v07PtRmloWaSVdpnMXUvTcFyl69cs5WlvZ7Eq/Z9ACRu4THm7K5rSjueyZuq9qNrUtE4a7T0nLo6rZoaZlU6PdpbreoqruUFFyqWG0qEFUKtW0Ll8EXXdHHswhcaY8tgFEdQM2+azBbUoUGyqH6jC43Kfkbs6BrvGYQ4nWhqa5Ht+yu5/Cpbe394lodG5YbmivsuBRhpevX19+p1isvWYYnaO27Q+vrqbe3tjYepPneCybLbzBY7bRGeZ3JEl7fXx84gXhITkk/Lc8wvA0w7P38Pj/nO35G53NMy0fXjCiAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Encoder representation\"\n        title=\"\"\n        src=\"/static/55a4d12aafa4699538801d1a8bf6a038/29492/encoded_representation.png\"\n        srcset=\"/static/55a4d12aafa4699538801d1a8bf6a038/12f09/encoded_representation.png 148w,\n/static/55a4d12aafa4699538801d1a8bf6a038/e4a3f/encoded_representation.png 295w,\n/static/55a4d12aafa4699538801d1a8bf6a038/29492/encoded_representation.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>The AE learns to distinguish some kinds of advertisment from non-advertisments quite well, so we could train a good classifier on those. However, we also see a big cluster, where ads and non-ads overlap significantly. We can conclude that in this region the spaming ads are very successful in hiding between the non-ads and we might have to do more feature engineering to find good splitting features.</p>\n<p>###Final notes for training an AE\nTo summarize, I want to provide a list of things that you can try for successfully training an AutoEncoder:</p>\n<ul>\n<li>Use the <a href=\"https://en.wikipedia.org/wiki/Activation_function\">softsign</a> function as activation. It is not as steep as the sigmoid and does not saturate as easily</li>\n<li>To choose the number and size of layers make reasonable steps between the input and output layers. Don't make the model to complex/big as you need more data to train it. Also think of using a tied encoder if the available data is small.</li>\n<li>Normalize and center your data to be uniform around <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></li>\n<li>Adjust the learning rates during training</li>\n<li>Monitor your layers to avoid saturation</li>\n</ul>\n<p>I hope this was helpful. As alwyas a <a href=\"https://github.com/jotterbach/Data-Exploration-and-Numerical-Experimentation/blob/master/Numerical-Experimentation/AutoEncoder_for_AdsDataset.ipynb\">IPython Notebook</a> is available on my personal github account. Enjoy playing with AutoEncoders!</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-fn-images\">There is one recent exception for image classification. It turns out that due to convolutioon and pooling increasing number of layers learn more and more complex features, that tend to <a href=\"https://www.cs.nyu.edu/~fergus/papers/zeilerECCV2014.pdf\">represent structures of the input images</a>. However, these cases are for foudn in supervised learning as opposed to autoencoders.<a href=\"#fnref-fn-images\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-fn-jpeg\">One such compression algorithm is jpeg. In a nutshell: To compress the data a two-dimensional Fourier transform is applied to the image. Afterwards the high-frequency components are removed, the inverse transformation performed and the resulting picture is stored. The result is a \"washing out\" of sharp edges resulting in a loss of contrast and a blurrier image, but reduced size.<a href=\"#fnref-fn-jpeg\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-fn-overfitting\">In practice this perfect separation might not be desirable as it indicates strong overfitting to the training data and makes generalization to new data questionable.<a href=\"#fnref-fn-overfitting\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-fn-jmetzen\">I also relied heavily on ideas presented in the very nice blog post of Jan Hendrik Metzen on <a href=\"https://jmetzen.github.io/2015-11-27/vae.html\">Variational Auto Encoders</a><a href=\"#fnref-fn-jmetzen\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","title":"Unsupervised Representation Learning a.k.a. Autoencoders"}},"staticQueryHashes":[],"slicesMap":{}}